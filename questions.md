# Коллоквиум по ОС(Иванова Виктория, 11 группа, нечетный вариант)

## Нулевая группа вопросов

### 1. Win API, необходимое для решения Лабораторной работы номер 3

Для выполнения лабораторной работы, связанной с потоками и синхронизацией в ОС Windows, могут понадобиться следующие функции из Win API:

- **Потоки**:
  - `CreateThread` — создает новый поток.
  - `ExitThread` — завершает выполнение потока.
  - `WaitForSingleObject` — ожидает завершения потока (или другого объекта синхронизации).
  - `GetExitCodeThread` — получает код завершения потока.
  
  Пример использования `CreateThread`:
  ```cpp
  DWORD WINAPI ThreadFunction(LPVOID lpParam) {
      return 0;
  }

  int main() {
      HANDLE hThread = CreateThread(NULL, 0, ThreadFunction, NULL, 0, NULL);
      WaitForSingleObject(hThread, INFINITE);
      CloseHandle(hThread);
      return 0;
  }
  ```

- **Мьютексы**:
  - `CreateMutex` — создает мьютекс.
  - `WaitForSingleObject` — ожидает захвата мьютекса.
  - `ReleaseMutex` — освобождает мьютекс.
  - `CloseHandle` — закрывает дескриптор мьютекса.

  Пример использования мьютекса:
  ```cpp
  HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
  WaitForSingleObject(hMutex, INFINITE);
  ReleaseMutex(hMutex);
  CloseHandle(hMutex);
  ```

- **События**:
  - `CreateEvent` — создает событие.
  - `SetEvent` — сигнализирует событие.
  - `WaitForSingleObject` — ожидает сигнала события.
  - `ResetEvent` — сбрасывает событие в несигнальное состояние.
  - `CloseHandle` — закрывает дескриптор события.

  Пример использования события:
  ```cpp
  HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
  SetEvent(hEvent);
  WaitForSingleObject(hEvent, INFINITE);
  ResetEvent(hEvent);
  CloseHandle(hEvent);
  ```

### 2. Что такое поток в ОС Windows?

Поток в операционной системе Windows — это отдельная единица выполнения, которая может выполняться независимо от других потоков в рамках одного процесса. Каждый поток имеет свой стек, а также может обращаться к общей памяти процесса, что позволяет эффективно использовать ресурсы процессора.

Потоки позволяют многозадачность в приложениях и используются для параллельного выполнения задач, таких как обработка пользовательского ввода, вычисления или операций ввода-вывода, без блокировки других процессов.

Пример создания потока:
```cpp
DWORD WINAPI ThreadFunction(LPVOID lpParam) {
    return 0;
}

int main() {
    HANDLE hThread = CreateThread(NULL, 0, ThreadFunction, NULL, 0, NULL);
    WaitForSingleObject(hThread, INFINITE)ж
    CloseHandle(hThread);
    return 0;
}
```

### 3. Что такое Мьютекс?

Мьютекс (mutual exclusion) — это объект синхронизации, используемый для обеспечения эксклюзивного доступа к ресурсу. Мьютекс позволяет только одному потоку иметь доступ к ресурсу в любой момент времени. Это используется для предотвращения состояния гонки, когда несколько потоков пытаются одновременно изменить данные.

Пример использования мьютекса:
```cpp
HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
if (WaitForSingleObject(hMutex, INFINITE) == WAIT_OBJECT_0) {
    ReleaseMutex(hMutex);
}
CloseHandle(hMutex);
```

### 4. Что такое Событие (объект синхронизации)?

Событие — это объект синхронизации, который позволяет потокам сообщать друг другу о наступлении определенного состояния. События могут быть в одном из двух состояний: сигнальном (set) или несигнальном (reset). Потоки могут ожидать события (блокироваться) или изменять его состояние (сигнализировать или сбрасывать).

Основные функции работы с событиями:
- **SetEvent**: Устанавливает событие в сигнальное состояние.
- **ResetEvent**: Сбрасывает событие в несигнальное состояние.
- **WaitForSingleObject**: Ожидает наступления сигнального состояния.

Пример использования события:
```cpp
HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
SetEvent(hEvent);
WaitForSingleObject(hEvent, INFINITE);
ResetEvent(hEvent);
CloseHandle(hEvent);
```

### 5. Сравнительный анализ стандарта C++98 и более свежего стандарта (например, C++11) в контексте лабораторных работ

1. **Типы данных и контейнеры**:
   - В **C++98** стандартный контейнерный класс `std::vector` существовал, но не было современного подхода к многозадачности и многопоточности.
   - В **C++11** появились новые возможности для работы с многозадачностью, такие как новые контейнеры и алгоритмы, а также улучшенные возможности для работы с памятью. Например, было добавлено множество новых стандартных контейнеров и улучшений, таких как `std::shared_ptr`, `std::unique_ptr`, которые упрощают управление памятью и улучшение производительности.

2. **Многозадачность**:
   - В **C++98** для многозадачности часто использовались сторонние библиотеки, такие как Boost, так как стандарт не содержал прямых средств для работы с потоками.
   - В **C++11** был добавлен стандартный функционал для многозадачности: `std::thread`, `std::mutex`, `std::atomic`, `std::future` и другие классы, что существенно упростило создание многозадачных приложений.

   Пример создания потока в C++11:
   ```cpp
   #include <iostream>
   #include <thread>

   void hello() {
       std::cout << "Hello from thread!" << std::endl;
   }

   int main() {
       std::thread t(hello);
       t.join();
       return 0;
   }
   ```

3. **Управление памятью**:
   - В **C++98** не было стандартных средств для управления памятью, помимо `new` и `delete`, что иногда приводило к утечкам памяти и сложностям с безопасностью.
   - В **C++11** были добавлены умные указатели `std::unique_ptr` и `std::shared_ptr`, что значительно улучшило безопасность работы с памятью.

4. **Лямбда-выражения**:
   - В **C++98** не существовало лямбда-выражений, что усложняло работу с функциональными объектами и анонимными функциями.
   - В **C++11** были введены лямбда-выражения, которые значительно упростили использование функций в качестве аргументов и улучшили читаемость кода.

   Пример лямбда-выражения:
   ```cpp
   #include <iostream>
   #include <algorithm>
   #include <vector>

   int main() {
       std::vector<int> v = {1, 2, 3, 4, 5};
       std::for_each(v.begin(), v.end(), [](int i) { std::cout << i << std::endl; });
       return 0;
   }
   ```

5. **Инициализация**:
   - В **C++98** инициализация переменных была ограничена конструкциями типа `int x = 5;`.
   - В **C++11** появились новые возможности, такие как инициализация через фигурные скобки (`int x{5};`), что снижает вероятность ошибок.

Таким образом, стандарт C++11 и более поздние версии значительно улучшили функциональность языка в плане многозадачности, безопасности работы с памятью и удобства кода, что особенно важно для выполнения лабораторных работ, требующих параллельных вычислений и взаимодействия между потоками.